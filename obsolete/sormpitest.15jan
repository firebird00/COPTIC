      program sormpitest
c
      integer Li,ni,nj
c      parameter (Li=100,ni=40,nj=40,nk=16)
      parameter (Li=100,ni=40,nj=40,nk=16)
      integer nblks
      parameter (nblks=1)
      integer nd
      parameter (nd=3,nd2=nd*2)
      real u(Li,Li,Li),q(Li,Li,Li),cij(nd2+1,Li,Li,Li)
      real error(Li,Li,Li)
      real zp(Li,Li),cijp(nd2+1,Li,Li)
      include 'objcom.f'
      include 'sormesh.f'
c
      external bdyset,faddu2,cijroutine
      real x(Li),y(Li),z(Li),xp(Li)
      character*100 form1,argument
      character*10 cxlab,cylab
      common /ctl_sor/mi_sor,xjac_sor,eps_sor,del_sor,k_sor
      logical lplot
c testing arrays
      integer iuds(nd),ifull(nd),idims(nd),ium2(nd)

      common /myidcom/myid

      lplot=.true.
      call getarg(1,argument)
      if(argument(1:2).eq.'-p') lplot=.false.

      ndims=nd

      dx2=1./ni**2
      dy2=1./nj**2
      dz2=1./nk**2

      idims(1)=nblks
      idims(2)=nblks
      ifull(1)=Li
      ifull(2)=Li
      iuds(1)=ni
      iuds(2)=nj
c This circumlocution quiets warnings.
      n3=3
      if(nd.eq.n3)then
         idims(n3)=nblks
         ifull(n3)=Li
         iuds(n3)=nk
      endif
      n0=nj/2
      n1=nk/2
      if(ndims.lt.3)n1=1

      iof=0
      do id=1,ndims
c Pointer to start of vector.
         ixnp(id)=iof
c Mesh size with the faces removed:
         ium2(id)=iuds(id)-2
c Mesh data:
         do i=1,iuds(id)
            xn(i+iof)=(i-1.)/(iuds(id)-1.)
         enddo
         iof=iof+iuds(id)
      enddo
c      write(*,'(10f8.4)')xn

c For possibly different jacobi convergence radius parameters.
      do kk=7,7,2
c This loop good for up to 3 dimensions.
         do k=1,nk
         do j=1,nj
            do i=1,ni
c initialize u, q, and cij
               u(i,j,k)=0.
c Charge rod
c               if(abs(i-ni/2).le.4 .and. abs(j-nj/2).le.4 )then
c Charge ball
               if(abs(i-ni/2).le.ni/6 .and. abs(j-nj/2).le.nj/6
     $              .and. abs(k-nk/2).le.nk/6)then
c Turned off.
c                  q(i,j,k)=1.
                  q(i,j,k)=0.
               else
                  q(i,j,k)=0.
               endif
c               q(i,j,k)=1.
c               do n=1,ndims
c                  cij(2*n-1,i,j,k)=iuds(n)**2
c                  cij(2*n,i,j,k)=iuds(n)**2
c               enddo
c No objects for now.
c               cij(2*ndims+1,i,j,k)=0.
            enddo
         enddo
         enddo

      ipoint=0
c      call mditerate(ndims,ifull,iuds,cijroutine,cij,ipoint)
c Remove edges by starting at (2,2,2,...) and using ium2.
      call mditerate(ndims,ifull,ium2,cijroutine,
     $     cij(1,2,2,2),ipoint)

      write(*,*)'Finished mesh setup. Used No of pointers:',oi_sor
c      write(*,'(a,8f8.1)')'cij(*,3,3,3)=',(cij(i,3,3,3),i=1,nd2+1)

c Example of object data pure fabrication.
c Turned off.
      nnodes=0
      do nn=1,nnodes
         i=ni/2
         j=nj/2
         k=nk/2
         cij(nd2+1,i,j,k)=nn
         do no=1,nobj_sor
            dob_sor(no,nn)=1
         enddo
         dob_sor(1,nn)=.9
         dob_sor(3,nn)=.4
         dob_sor(5,nn)=.5
         dob_sor(7,nn)=.8
         dob_sor(9,nn)=.7
         dob_sor(11,nn)=.8
      enddo


c This jacobi radius is pretty much optimized for Poisson equation with
c fixed boundary, 2-dimensional, when kk=5. 3-d not optimized.
      xyimb=(max(ni,nj)*2.)/float(ni+nj) - 1.
      xjac_sor=1.- ((kk/5.)*4./max(10,(ni+nj)/2)**2)
     $     *(1.-0.3*xyimb)
      mi_sor=4*(ni+nj+nk)+10
      eps_sor=1.e-5
c Stop iterating immediately
c         mi_sor=3
         
c Control. Bit 1, use my sor parameters, Bit 2 use faddu.
      ictl=3
c         ictl=1
c         write(*,*)'Calling sormpi, ni,nj=',ni,nj
c The main solver call. Returns process myid.
      call sormpi(ndims,ifull,iuds,cij,u,q,bdyset,faddu2,ictl,ierr
     $     ,myid,idims,nobj_sor,dob_sor)


         if(myid.eq.0)then
            if(ierr.lt.0) write(*,*)'Not converged',ierr
            write(*,*) 'mi_sor,k_sor,xjac_sor,del_sor',
     $           mi_sor,k_sor,xjac_sor,del_sor,myid
            if(ni+nj.lt.40) then
               write(form1,'(''('',i4,''f8.5)'')')nj
               write(*,*)'u='
               write(*,form1)((u(i,j,n1),j=1,nj),i=1,ni)
            endif
         endif
      enddo

         
      if(myid.eq.0.and.lplot)then
         call cijplot(ndims,ifull,iuds,cij)
      endif

c      write(*,*)'Returned myid=',myid

c      iform=7
c      uscale=10000000.
c      call udisplay(ndims,u,ifull,iuds,iform,uscale)
c-------------------------------------------------------------------
c Start of plotting section.
      if(myid.eq.0)then
         if(lplot) then
            call yautoplot(u(1,n0,n1),ni)
            do i=1,ni
               xr=xn(i)
               yr=xn(iuds(1)+n0)
               zr=xn(iuds(1)+iuds(2)+n1)
               r=sqrt((xr-.5)**2+(yr-.5)**2+(zr-.5)**2)
               z(i)=2.*.2/r
               xp(i)=i
            enddo
            call polyline(xp,z,ni)
            call pltend()
            write(*,*)'Height nz=',n1,
     $           ' Use up/down arrows to adjust.',
     $           ' Use s to rescale. Drag mouse to rotate.',
     $           ' Use left/right arrows to change dimension.'
c Plotting slices.
            ifix=3
            if(.true.)then
            call slice3web(ifull,iuds,u,cij,Li,zp,cijp,ixnp,xn,ifix,
     $           'potential:'//'!Ay!@')
            else
c     Plot the surface. With scaling 1. Web color 6, axis color 7.
            jsw=1 + 256*6 + 256*256*7
 21         call pltinit(0.,1.,0.,1.)
c Set the plotting arrays for fixed dimension ifix.
            nf1=iuds(mod(ifix,3)+1)
            call iwrite(mod(ifix,3)+1,iwidth,cxlab)
            nf2=iuds(mod(ifix+1,3)+1)
            call iwrite(mod(ifix+1,3)+1,iwidth,cylab)
            do i=1,nf1
               x(i)=xn(ixnp(mod(ifix,3)+1)+i)
               do j=1,nf2
                  if(i.eq.1)y(j)=xn(ixnp(mod(ifix+1,3)+1)+j)
                  if(ifix.eq.1)then
                     zp(i,j)=u(n1,i,j)
                     do k=1,nd2+1
                        cijp(k,i,j)=cij(k,n1,i,j)
                     enddo
                  elseif(ifix.eq.2)then
                     zp(i,j)=u(j,n1,i)
                     do k=1,nd2+1
                        cijp(k,i,j)=cij(k,j,n1,i)
                     enddo
                  elseif(ifix.eq.3)then
                     zp(i,j)=u(i,j,n1)
                     do k=1,nd2+1
                        cijp(k,i,j)=cij(k,i,j,n1)
                     enddo
                  endif
               enddo
            enddo

c     write(*,*)'Starting hidweb'
c            call hidweb(x,y,u(1,1,n1),Li,ni,nj,jsw)
            call hidweb(x,y,zp,Li,nf1,nf2,jsw)
c Use this scaling until explicitly reset.
            jsw=0 + 256*6 + 256*256*7
            write(form1,'(''Dimension '',i1,'' Plane'',i4)')ifix,n1
            call drwstr(.1,.05,form1)
            call ax3labels('axis-'//cxlab,'axis-'//cylab,
     $           'potential:'//'!Ay!@')
c Here we want to mark bounding surfaces, which are associated with those
c cijs that have non-zero pointer.
            call surfmark(Li,nf1,nf2,x,y,zp,cijp,ifix)
            call eye3d(isw)
            if(isw.eq.0) goto 23
            if(isw.eq.65364 .and. n1.gt.1) n1=n1-1
            if(isw.eq.65362 .and. n1.lt.iuds(ifix)) n1=n1+1
            if(isw.eq.ichar('q')) goto 23
            if(isw.eq.ichar('s'))jsw=1 + 256*6 + 256*256*7
            if(isw.eq.65361)then
               ifix=mod(ifix+1,3)+1
               n1=iuds(ifix)/2
            elseif(isw.eq.65363)then
               ifix=mod(ifix,3)+1
               n1=iuds(ifix)/2
            endif
            goto 21
 23         continue
            endif
         endif
c-------------------------------------------------------------------
c Write some data out for cross checking
c Delete the file first to help with nfs problems.
         open(21,file='smt.round',status='unknown')
         close(21,status='delete')
         open(21,file='smt.round',status='unknown')
         write(21,*)ni,nj,nk/2
         write(21,'(6e12.4)')((u(i,j,nk/2),i=1,ni/2),j=1,nj/2)
         close(21)
c Delete the file first to help with nfs problems.
         open(20,file='smt.out',status='unknown')
         close(20,status='delete')
         open(20,file='smt.out',status='unknown')
         write(20,*)ni,nj,nk/2
         write(20,*)((u(i,j,nk/2),i=1,ni/2),j=1,nj/2)
         close(20)
c-------------------------------------------------------------------
c Do some analytic checking of the case with a fixed potential sphere
c inside a logarithmic derivative boundary condition. 1/r solution.
      rc=.2
      errmax=0.
      errvar=0.
      count=0
      do i=2,ni-1
         do j=2,nj-1
            do k=2,nk-1
               count=count+1.
               r=0.
               xr=xn(i)
               yr=xn(iuds(1)+j)
               zr=xn(iuds(1)+iuds(2)+k)
               r=sqrt((xr-.5)**2+(yr-.5)**2+(zr-.5)**2)
               if(u(i,j,k).gt.1.e-4 .and.
     $              r.ge.rc)then
                  e=u(i,j,k)-2.*rc/r
                  error(i,j,k)=e
                  errvar=errvar+e**2
                  if(abs(e).gt.abs(errmax))errmax=e
c                  if(abs(e).gt.1.e-3) 
c                  write(*,'(3i3,10f8.4)')i,j,k,
c     $                 xr,yr,zr,r,u(i,j,k),2.*rc/r,e
               else
                  error(i,j,k)=0.
               endif
            enddo
         enddo
      enddo
      errvar=errvar/count
      write(*,*)'Max error=',errmax,'  Standard Deviation=',sqrt(errvar)
      endif
c-------------------------------------------------------------------
      call MPI_FINALIZE(ierr)
      end
c**********************************************************************
c**********************************************************************
      subroutine bdyset0(ndims,ifull,iuds,cij,u,q)
c     Null version
      end
c**********************************************************************
      subroutine bdyset(ndims,ifull,iuds,cij,u,q)
      integer ndims,ifull(ndims),iuds(ndims)
      real cij(*),u(*),q(*)
      external bdy3slope
c set the derivative to zero on boundaries 3.
      ipoint=0
      call mditerate(ndims,ifull,iuds,bdy3slope,u,ipoint)

c set the second derivative to zero on max j
c      do i=2,ni-1
c         u(i,nj)=relax*(2.*u(i,nj-1)-u(i,nj-2)) +(1.-relax)*u(i,nj)
c      enddo
      end
c**********************************************************************
      real function faddu0(u,fprime)
      faddu0=0.
      slope=1000.
      faddu=(u)*slope
      fprime=slope
      end
c**********************************************************************
      real function faddu(u,fprime)
      real u,fprime
      real*8 slope,expu,temp
      faddu1=0
      slope=1000.
      temp=u
      expu=exp(temp)
      faddu=(expu-1.D0)*slope
      fprime=faddu+slope
      end
c**********************************************************************
      real function faddu2(u,fprime)
      faddu2=0.
      faddu=0.
      fprime=0.
      end

c************************************************************************
      subroutine bdy3slope(inc,ipoint,indi,ndims,iused,u)
c Version of bdyroutine that sets derivative=0 on 3-boundary.
      integer ipoint,inc
      integer indi(ndims),iused(ndims)
      real u(*)

      parameter (mdims=10)
c Structure vector needed for finding adjacent u values.
      integer iLs(mdims+1)
      common /iLscom/iLs

c Algorithm: if on a boundary face of dimension >1, steps of 1 (dim 1).
c Otherwise steps of iused(1)-1 or 1 on first or last (of dim 1).
      inc=1
      do n=ndims,2,-1
         if(indi(n).eq.0)then
c On boundary face 0 of dimension n>1. Break.
c This is where we put boundary setting for n>1
            u(ipoint+1)=0.
            if(n.eq.3)then
c Second derivative is zero:
c               u(ipoint+1)=2.*u(ipoint+1+iLs(n))-u(ipoint+1+2*iLs(n)
c First derivative is zero:
               u(ipoint+1)=u(ipoint+1+iLs(n))
            endif
            goto 101
         elseif(indi(n).eq.iused(n)-1)then
c On boundary face iused(n) of dimension n>1. Break.
            u(ipoint+1)=0.
            if(n.eq.3) u(ipoint+1)=u(ipoint+1-iLs(n))
            goto 101
         endif
      enddo
c     We are not on any higher boundary.
c This is where the boundary setting is done for n=1
      u(ipoint+1)=0.
      if(indi(n).eq.0)then
         inc=iused(1)-1
      elseif(indi(n).eq.iused(n)-1)then
         inc=1
      else
         write(*,*)'BDY Error. We should not be here',
     $        n,ipoint,indi
         stop
      endif
 101  continue
c      write(*,*)'indi,inc,iused,ipoint',indi,inc,iused,ipoint

      end
c************************************************************************
      subroutine surfmark(Li,ni,nj,x,y,z,cij,ifix)
c Mark in 3-D the positions of those points at which cij(7,*,*) are non
c -zero. 
      integer Li,ni,nj
      real x(ni),y(nj)
      real z(Li,nj)
      real cij(7,Li,nj)
      include 'objcom.f'

      call color(3)
      do i=1,ni
         do j=1,nj
            ipoint=cij(7,i,j)
            if(ipoint.ne.0)then
               call wxyz2nxyz(x(i),y(j),z(i,j),xn,yn,zn)
               do id=1,3
                  idff=mod(id-1+3-ifix,3)+1
                  do jd=1,2
                     iobj=4*(id-1)+2*(jd-1)+1
                     fraction=dob_sor(iobj,ipoint)
                     if(fraction.ne.1.)then
c                        write(*,*)i,j,ipoint,id,jd,fraction
                        ip=i
                        jp=j
                        zp=z(i,j)
                        if(idff.eq.1)ip=ip+(3-2*jd)
                        if(idff.eq.2)jp=jp+(3-2*jd)
                        if(idff.eq.3)zp=zp+.05*(3-2*jd)
                        call vec3n(xn,yn,zn,0)
                        call vec3w(x(i)*(1.-fraction)+x(ip)*fraction,
     $                       y(j)*(1.-fraction)+y(jp)*fraction,
     $                       z(i,j)*(1.-fraction)+zp*fraction,1)
                     endif
                  enddo
               enddo
            endif
         enddo
      enddo

      end
c*******************************************************************
      subroutine slice3web(ifull,iuds,u,cij,nw,zp,cijp,ixnp,xn,ifix,
     $           utitle)
      parameter(ndims=3,nd2=2*ndims)
c Plot web projected representations of potential u on slices with
c fixed values of dimension ifix. Mark cij boundaries.
c The full dimensions of arrays u, cij
      integer ifull(ndims)
      real u(ifull(1),ifull(2),ifull(3))
      real cij(2*ndims+1,ifull(1),ifull(2),ifull(3))
c The used dimensions of each are
      integer iuds(ndims)
c The dimensions of square working arrays, zp, cijp must be larger
c than the greatest of iuds 
      integer nw
      real zp(nw,nw)
      real cijp(2*ndims+1,nw,nw)
c The point positions are given by vectors laminated into xn, whose
c starts are at ixnp(id)+1. 
      integer ixnp(ndims)
      real xn(500)
c The starting fixed dimension is
      integer ifix
c The plotted quantity title is
      character*(*) utitle
c
c Local variables:
      character*(10) cxlab,cylab
      character*(30) form1

      n1=iuds(ifix)/2
c     Plot the surface. With scaling 1. Web color 6, axis color 7.
      jsw=1 + 256*6 + 256*256*7
 21   call pltinit(0.,1.,0.,1.)
c Set the plotting arrays for fixed dimension ifix.
      idp1=mod(ifix,3)+1
      idp2=mod(ifix+1,3)+1
      nf1=iuds(idp1)
      call iwrite(idp1,iwidth,cxlab)
      nf2=iuds(idp2)
      call iwrite(idp2,iwidth,cylab)
      do i=1,nf1
c         x(i)=xn(ixnp(mod(ifix,3)+1)+i)
         do j=1,nf2
c            if(i.eq.1)y(j)=xn(ixnp(mod(ifix+1,3)+1)+j)
            if(ifix.eq.1)then
               zp(i,j)=u(n1,i,j)
               do k=1,nd2+1
                  cijp(k,i,j)=cij(k,n1,i,j)
               enddo
            elseif(ifix.eq.2)then
               zp(i,j)=u(j,n1,i)
               do k=1,nd2+1
                  cijp(k,i,j)=cij(k,j,n1,i)
               enddo
            elseif(ifix.eq.3)then
               zp(i,j)=u(i,j,n1)
               do k=1,nd2+1
                  cijp(k,i,j)=cij(k,i,j,n1)
               enddo
            endif
         enddo
      enddo

      call hidweb(xn(ixnp(idp1)+1),xn(ixnp(idp2)+1),zp,nw,nf1,nf2,jsw)
c Use this scaling until explicitly reset.
      jsw=0 + 256*6 + 256*256*7
      write(form1,'(''Dimension '',i1,'' Plane'',i4)')ifix,n1
      call drwstr(.1,.02,form1)
      call ax3labels('axis-'//cxlab,'axis-'//cylab,utitle)
c Here we want to mark bounding surfaces, which are associated with those
c cijs that have non-zero pointer.
      call surfmark(nw,nf1,nf2,xn(ixnp(idp1)+1),xn(ixnp(idp2)+1),
     $     zp,cijp,ifix)
      call eye3d(isw)
      if(isw.eq.0) goto 23
      if(isw.eq.65364 .and. n1.gt.1) n1=n1-1
      if(isw.eq.65362 .and. n1.lt.iuds(ifix)) n1=n1+1
      if(isw.eq.ichar('q')) goto 23
      if(isw.eq.ichar('s'))jsw=1 + 256*6 + 256*256*7
      if(isw.eq.65361)then
         ifix=mod(ifix+1,3)+1
         n1=iuds(ifix)/2
      elseif(isw.eq.65363)then
         ifix=mod(ifix,3)+1
         n1=iuds(ifix)/2
      endif
      goto 21
 23   continue
      end
